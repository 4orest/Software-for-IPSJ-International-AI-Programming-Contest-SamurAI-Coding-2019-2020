#include "players.hh"

int planDog(GameInfo &info) {
  if (info.step == 0) initFieldMap(info);
  int failedPlan =		// Plan failed in the previous step
    info.plans[info.id] != info.actions[info.id] ? info.plans[info.id] : -2;
  Cell pos = info.positions[info.id];
  CellInfo &myCell = cells[pos.x][pos.y];
  for (CellInfo *n: myCell.eightNeighbors) n->inspected = true;
  Cell samuraiPos = info.positions[info.id - 2];
  CellInfo *samuraiCell = &cells[samuraiPos.x][samuraiPos.y];
  Cell oppPos = info.positions[1 - info.id%2];
  CellInfo *oppCell = &cells[oppPos.x][oppPos.y];
  if (info.revealedTreasure.find(pos) != info.revealedTreasure.end()) {
    // The dog is in the cell with known gold
    bool friendCanDig = false;
    bool oppCanDig = false;
    for (CellInfo *p: myCell.fourNeighbors) {
      if (p == samuraiCell) friendCanDig = true;
      else if (p == oppCell) oppCanDig = true;
    }
    // If opponent samurai can dig, but friend samurai can't,
    // then sit there still to prevent opponent's digging.
    if (oppCanDig && !friendCanDig) return -1;
  }
  Cell candidate;
  int largestDiff = -1;
  int largestAmount = 0;
  for (auto s: info.sensedTreasure) {
    CellInfo *sensed = &cells[s.first.x][s.first.y];
    int distDiff = 
      samuraiDistance(oppCell, sensed, info.holes) -
      samuraiDistance(samuraiCell, sensed, info.holes);
    if (distDiff > largestDiff ||
	(distDiff == largestDiff && s.second > largestAmount)) {
      // If friend samurai is closer than the opponent samurai to a sensed gold,
      // Check if no other agents are in the gold cell.
      if (noAgentsIn(s.first, info)) {
	largestDiff = distDiff;
	largestAmount = s.second;
	candidate = s.first;
      }
    }
  }
  if (largestAmount > 0) return directionOf(pos, candidate);
  // Random Walk
  vector <int> candidates;
  for (CellInfo *c: myCell.eightNeighbors) {
    Cell n = c->position;
    if (info.holes.count(n) == 0 && noAgentsIn(n, info)) {
      int plan = directionOf(pos, n);
      if (plan != failedPlan) candidates.push_back(plan);
    }
  }
  if (candidates.size() == 0) return -1;
  return candidates[rand()%candidates.size()];
}
